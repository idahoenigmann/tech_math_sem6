\documentclass[]{article}
\usepackage[a4paper, margin=2.5cm]{geometry}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{amsthm}
\usepackage[many]{tcolorbox}
\usepackage{listings}

\newtheorem{lemma}{Lemma}
\newtheorem*{definition*}{Def}
\newtheorem{algorithm}{Algorithm}

\tcolorboxenvironment{lemma}{
	colback=yellow!5!white,
	boxrule=0pt,
	boxsep=1pt,
	left=2pt,right=2pt,top=2pt,bottom=2pt,
	oversize=2pt,
	sharp corners,
	before skip=\topsep,
	after skip=\topsep,
}

\tcolorboxenvironment{definition*}{
	colback=green!5!white,
	boxrule=0pt,
	boxsep=1pt,
	left=2pt,right=2pt,top=2pt,bottom=2pt,
	oversize=2pt,
	sharp corners,
	before skip=\topsep,
	after skip=\topsep,
}
\begin{document}
	
\title{Automated Deduction Compendium SS2023}
\author{Ida HÃ¶nigmann}

\maketitle

\section{Introduction, SAT Solving}

\subsubsection{Proposition, Formulas}
\begin{definition*}[Proposition]
	Proposition is a statement that can be either true or false.
\end{definition*}

\begin{definition*}[Propositional formula, Atom, Connective]
	Atoms are boolean variables (e.g. p,q).
	
	\begin{itemize}
		\item Atoms are formulas.
		\item $\top$, $\bot$ are formulas.
		\item If $A$ is a formula, then $\lnot A$ is a formula.
		\item If $A_1, ..., A_n$ are formulas, then $(A_1 \land ... \land A_n)$ and $(A_1 \lor ... \lor A_n)$ are formulas.
		\item If $A$ and $B$ are formulas, then $A \rightarrow B$ and $A \leftrightarrow B$ are formulas.
	\end{itemize}

	The symbols $\top, \bot, \land, \lor, \lnot, \rightarrow, \leftrightarrow$ are called logical connectives.
\end{definition*}

\subsubsection{Precedence}
\begin{center}
	\begin{tabular}{|c c c|}
		\hline
		Connective & Name & Precedence \\
		\hline
		$\top$            & verum       &   \\  
		$\bot$            & falsum      &   \\
		$\lnot$           & negation    & 5 \\  
		$\land$           & conjunction & 4 \\
		$\lor$            & disjunction & 3 \\  
		$\rightarrow$     & implication & 2 \\
		$\leftrightarrow$ & equivalence & 1 \\  
		\hline
	\end{tabular}
\end{center}

\subsubsection{Boolean Values, Interpretation}
\begin{definition*}[Boolean values, Interpretation]
	There are two boolean vales: true ($1$) and false ($0$).
	
	An interpretation for a set $P$ of boolean variables is a mapping $I : P \rightarrow \{0,1\}$.
\end{definition*}

\subsubsection{Interpreting formulas}
\begin{itemize}
	\item $I(\top) = 1$ and $I(\bot) = 0$
	\item $I(A_1 \land ... \land A_n) = 1$ iff $I(A_i) = 1$ for all $i$
	\item $I(A_1 \lor ... \lor A_n) = 1$ iff $I(A_i) = 1$ for some $i$
	\item $I(\lnot A) = 1$ iff $I(A) = 0$
	\item $I(A_1 \rightarrow A_2) = 1$ iff $I(A_1) = 0$ or $I(A_2) = 1$
	\item $I(A_1 \leftrightarrow A_2) = 1$ iff $I(A_1) = I(A_2)$
\end{itemize}

\subsubsection{Safisfiable, Valid, Model}
\begin{definition*}[Satisfiable, Model, Valid]
	If $I(A) = 1$ then $I$ satisfies $A$ and $I$ is a model of $A$, denoted by $I \models A$.
	
	$A$ is satisfiable if some interpretation is a model of $A$.
	
	$A$ is valid if every interpretation is a model of $A$.
	
	$A$ and $B$ are equivalent, denoted by $A \equiv B$, if they have the same models.
\end{definition*}

\subsubsection{Connection valid, satisfiable}
\begin{itemize}
	\item $A$ is valid iff $\lnot A$ is unsatisfiable.
	\item $A$ is satisfiable iff $\lnot A$ is not valid.
\end{itemize}

\subsubsection{Equivalent replacement}
\begin{definition*}[Equivalent replacement]
	$A[B]$ is a formula $A$ with a fixed occurrence of subformula $B$. $A[B']$ is the formula $A$ where every occurrence of $B$ is replaced by $B'$.
\end{definition*}

\begin{lemma}[Equivalent Replacement]
	Let $I$ be an interpretation and $I \models A_1 \leftrightarrow A_2$. Then $I \models B[A_1] \leftrightarrow B[A_2]$.
	
	Let $A_1 \equiv A_2$. Then $B[A_1] \equiv B[A_2]$.
\end{lemma}


\subsubsection{Evaluating a formula}
\begin{algorithm}
\begin{verbatim}
procedure evaluate(G,I)
input: formula G, interpretation I
output: the boolean value I(G)
begin
  forall atoms p occurring in G
    if I models p
      then replace all occurrences of p in G by 1;
      else replace all occurrences of p in G by 0;
  rewrite G into a normal form using the rewrite rules
  if G = 1 then return 1 else return 0
end
\end{verbatim}
\end{algorithm}

\section{Splitting, Polarities}

\subsubsection{Soundness of Splitting}

$A_p^\bot$ and $A_p^\top$ are obtained by replacing in $A$ all occurrences of $p$ by $\bot$ and $\top$ respectively.

\begin{lemma}
	Let $p$ be an atom, $A$ be a formula, and $I$ be an interpretation.
	
	\begin{itemize}
		\item If $I \not\models p$, then $A$ is equivalent to $A_p^\bot$ in $I$.
		\item If $I \models p$, then $A$ is equivalent to $A_p^\top$ in $I$.
	\end{itemize}
\end{lemma}

\begin{lemma}
	Let $A$ be a formula and $p$ an atom.
	
	Then $A$ is satisfiable iff at least one of the formulas $A_p^\top$ and $A_p^\bot$ is satisfiable.
\end{lemma}

\subsubsection{Splitting}

\begin{algorithm}
	\begin{verbatim}
		procedure split(G)
		parameters: function select
		input: formula G
		output: ''satisfiable'' or ''unsatisfiable''
		begin
		  G := simplify(G)		# rewrite rules
		  if G = 1 then return ''satisfiable''
		  if G = 0 then return ''unsatisfiable''
		  (p,b) := select(G)
		  case b of
		  1 =>
		    if split(replace(G,p,1)) = ''satisfiable''
		      then return ''satisfiable''
		      else return split(replace(G,p,0))
		  0 =>
		    if split(replace(G,p,0)) = ''satisfiable''
		      then return ''satisfiable''
		      else return split(replace(G,p,1))
		end
	\end{verbatim}
\end{algorithm}

\subsubsection{Polarities}
\begin{itemize}
	\item $A|_\epsilon = A$ and $pol(A,\epsilon) = 1$
	\item If $A|\pi = B_1 \land ... \land B_n$ or $A|\pi = B_1 \lor ... \lor B_n$ then $A|_{\pi.i} = B_i$ and $pol(A,\pi.i) = pol(A,\pi)$.
	\item If $A|_pi = \lnot B$ then $A|_{\pi.1} = B$ and $pol(A,\pi.1) = -pol(A,\pi)$.
	\item If $A|_\pi = B_1 \rightarrow B_2$ then $A|_{\pi.1} = B_1$, $A|_{\pi.2} = B_2$ and $pol(A,\pi.1) = -pol(A,\pi)$, $pol(A,\pi.2) = pol(A,\pi)$.
	\item If $A|_\pi = B_1 \leftrightarrow B_2$ then $A|_{\pi.1} = B_1$, $A|_{\pi.2} = B_2$ and $pol(A,\pi.1) = 0 = pol(A,\pi.2)$.
\end{itemize}

\subsubsection{Monotonic replacement}

Denote with $A[B]_\pi$ formula $A$ with the subformula at the position $\pi$ replaced by $B$.

\begin{lemma}[Monotonic Replacement]
	Let $A,B,B'$ be formulas, $I$ be an interpretation, and $I \models B \rightarrow B'$. If $pol(A,\pi) = 1$, then $I \models A[B]_\pi \rightarrow A[B']_\pi$. Likewise, if $pol(A,\pi) = -1$ then $I \models A[B']_\pi \rightarrow A[B]_\pi$.
\end{lemma}

\subsubsection{Pure Atom}

\begin{definition*}
	Atom $p$ is pure in a formula $A$, if either all occurrences of $p$ in $A$ are positive or all occurrences of $p$ in $A$ are negative.
\end{definition*}

\begin{lemma}[Pure Atom]
	Let $p$ have only positive occurrences in $A$ and $I \models A$. Define $I' = I + (p\mapsto 1)$. Then $I' \models A$. Likewise, let $p$ have only negative occurrences in $A$ and $I \models A$. Define $I' = I + (p\mapsto 0)$. Then $I' \models A$.
\end{lemma}

\begin{lemma}[Pure Atom]
	Let an atom $p$ have only positive (respectively, only negative) occurrences in $A$. Then $A$ is satisfiable iff $A_p^\top$ (respectively, $A_p^\bot$) is satisfiable.
\end{lemma}

\subsubsection{Splitting with pure atom optimization}

\begin{algorithm}
	\begin{verbatim}
		procedure split(G)
		parameters: function select
		input: formula G
		output: ''satisfiable'' or ''unsatisfiable''
		begin
		  G := simplify_with_pure_atoms(G)
		  if G = 1 then return ''satisfiable''
		  if G = 0 then return ''unsatisfiable''
		  (p,b) := select(G)
		  case b of
		  1 =>
		    if split(replace(G,p,1)) = ''satisfiable''
		      then return ''satisfiable''
		      else return split(replace(G,p,0))
		  0 =>
		    if split(replace(G,p,0)) = ''satisfiable''
		      then return ''satisfiable''
		      else return split(replace(G,p,1))
		end
	\end{verbatim}
\end{algorithm}

\section{CNF, DPLL, MiniSat}

\subsubsection{Clause}

\begin{definition*}[Literal, Clause, Empty clause, Unit clause, Horn clause]
	A literal is either an atom $p$ or its negation $\lnot p$.
	
	A clause is a disjunction of literals $L_1 \lor ... \lor L_n$.
	
	The empty clause $\square$ is false in every interpretation.
	
	If $n=1$ then the clause is called unit clause.
	
	A horn clause is a clause with at most one positive literal.
\end{definition*}

\subsubsection{CNF}

\begin{definition*}[CNF]
	A formula $A$ is in conjenctive normal form if it is $\top$, $\bot$ or a conjunction of disjunctions of literals $\bigwedge_i \bigvee_j L_{i,j}$.
\end{definition*}

\subsubsection{Naming}

If A is a non-trivial subformula $A$. Introduce a new name $n$ for it. Add formula $n \leftrightarrow A$ and replace subformula by its name in the original formula.

\begin{lemma}[Naming]
	Let $S$ be a set of formulas and $A$ a formula. Let $n$ be a boolean variable not occurring in $S$, nor in $A$.
	
	Then $S$ is satisfiable iff the set of formulas $S \cup \{n \leftrightarrow A\}$ is satisfiable.
\end{lemma}

\subsubsection{Optimized CNF Transformation}

Introduce a new name $n$ every subformula $B$ and replace it with the name. If the subformula occurs only positively then add $n \rightarrow B$. If it occurs only negatively then add $B \rightarrow n$ and if it does not occur only positively or negatively than add $n \leftrightarrow B$.

\begin{lemma}
	A set of formulas is satisfiable iff the optimized CNF transformation of these formulas is satisfiable.
\end{lemma}

\subsubsection{Unit propagation}

Let $S$ be a set of clauses. If $S$ contains a unit clause $L$ then remove from $S$ every clause of the form $L \lor C$ and replace in $S$ every clause of the form $\bar{L} \lor C$ by the clause $C$.

\subsubsection{DPLL = splitting + unit propagation}

\begin{algorithm}
	\begin{verbatim}
		procedure DPLL(S)
		input: set of clauses S
		output: satisfiable or unsatisfiable
		parameters: function select_literal
		begin
		  S := propagate(S) # unit propagation
		  if S is empty then return satisfiable
		  if S contains 0 then return unsatisfiable
		  L := select_literals(S) # splitting
		  if DPLL(S union {L}) = satisfiable
		    then return satisfiable
		    else return DPLL(S union {not L})
		end
	\end{verbatim}
\end{algorithm}

Tautologies (e.g. $p \lor \lnot p \lor C$) can be removed.

\subsubsection{Pure literals}

\begin{definition*}[Pure literal]
	A literal $L$ in $S$ is called pure if $S$ contains no clauses of the form $\bar{L} \lor C$.
\end{definition*}

If $L$ is a pure literal in $S$ then all clauses containing this literal can be removed.

\section{Random SAT, Horn clauses}

\subsubsection{Random Clause Generation}

Fix a number $n$ of boolean variables. Fix the length $k$ of the clause. Choose $k$ times a random literal $p_1, .., p_n, \lnot p_1, ..., \lnot p_n$ with equal probability.

\subsubsection{k-SAT}

We can reduce SAT to 3-SAT by naming: Let $L_1 \lor L_2 \lor L_3 \lor L4 \lor ...$ be a clause with more then 3 literals. Then we can replace it with $L_1 \lor L_2 \lor n$ and $\lnot n \lor L_3 \lor L4 \lor ...$ where $n$ is a new variable.

SAT is NP-complete. 2-SAT is decidable in linear time. 3-SAT is NP-complete.

\subsubsection{Chaos Algorithm, GSAT, WSAT}

\begin{algorithm}
	\begin{verbatim}
		procedure chaos(S)
		input: set of clauses S
		output: interpretation I such that I models S or don't know
		parameters: positive interger max_tries
		begin
		  repeat max_tries times
		    I := random interpretation
		    if I models S then return I
		  return don't know
		end
	\end{verbatim}
\end{algorithm}

\begin{algorithm}
	\begin{verbatim}
		procedure GSAT(S)
		input: set of clauses S
		output: interpretation I such that I models S or don't know
		parameters: positive intergers max_tries, max_flips
		begin
		  repeat max_tries times
		    I := random interpretation
		    if I models S then return I
		    repeat max_flips times
		      p := a variable such that flip(I, p) satisfies the maximal number of clauses in S
		      I = flip(I,p)
		      if I models S then return I
		  return don't know
		end
	\end{verbatim}
\end{algorithm}

\begin{algorithm}
	\begin{verbatim}
		procedure WSAT(S)
		input: set of clauses S
		output: interpretation I such that I models S or don't know
		parameters: positive intergers max_tries, max_flips
		begin
		  repeat max_tries times
		    I := random interpretation
		    if I models S then return I
		    repeat max_flips times
		      randomly select a clause C in S such that I does not model C
		      randomly select a variable p in C
		      I = flip(I,p)
		      if I models S then return I
		  return don't know
		end
	\end{verbatim}
\end{algorithm}

\subsubsection{SAT of Horn clauses}

Satisfiability of horn clauses can be decided using unit propagation.

\section{First-Order Logic, Theories}

\subsubsection{Syntax}

\begin{definition*}[Signature]
	A signature consists of
	\begin{itemize}
		\item a set of sorts (e.g. integers, arrays of rationals) denoted by $\alpha, \beta$.
		\item constants, denoted by $a,b,c$. Each constant $c$ has a sort $\alpha$, written $c: \alpha$.
		\item function symbols, denoted by $f,g$. Each function symbol $f$ has a type $\alpha_1 \times ... \times \alpha_n \rightarrow \alpha$.
		\item Predicate symbols, denoted by $p,q$. Each predicate symbol $p$ has a type $\alpha_1 \times ... \times \alpha_n$.
	\end{itemize}
\end{definition*}

Variables are not part of the signature, but do have sorts.

\begin{definition*}[Interpretation]
	An interpretation $I$ maps
	\begin{itemize}
		\item each sort to a non-empty set, called the domain of this sort.
		\item each constant $c:\alpha$ to an element $c' \in I(\alpha)$.
		\item each variable $x: \alpha$ to an element $x' \in I(\alpha)$.
		\item each function symbol $f: \alpha_1 \times ... \times \alpha_n \rightarrow \alpha$ to a function $f':I(\alpha_1) \times ... \times I(\alpha_n) \rightarrow I(\alpha)$.
		\item each predicate symbol $p: \alpha_1 \times ... \times \alpha_n$ to a relation $p'$ on $I(\alpha_1) \times ... \times I(\alpha_n)$.
	\end{itemize}
\end{definition*}

\begin{definition*}[Term, Atomic Formula]
	Terms of the sort $\alpha$ are constants $c: \alpha$ or variables $x: \alpha$. If $t_1, ..., t_n$ are terms of the sorts $\alpha_1, ..., \alpha_n$ and $f: \alpha_1 \times ... \times \alpha_n \rightarrow \alpha$, then $f(t_1, ..., t_n)$ is a term of the sort $\alpha$.
	
	An atomic formula is an expression $p(t_1, ..., t_n)$ where $p: \alpha_1 \times ... \times \alpha_n$ and $t_1, ..., t_n$ are terms of sorts $\alpha_1, ..., \alpha_n$.
\end{definition*}

Note that $=$ and $>$ are interpreted, but other symbols are uninterpreted.

\begin{definition*}[Formula, Quantifier, Bound, Free, Ground]
	Let $A$ be a formula and $x$ a variable, then $\forall x A$ and $\exists x A$ are formulas.
	
	The symbols $\forall, \exists$ are called quantifiers.
	
	A variable occurring in a formula $A$ is called bound, if it is in the scope of a quantifier, otherwise it is called free.
	
	A formula is called ground or quantifier-free if it contains no occurrences of quantifiers.
\end{definition*}

\begin{definition*}[x-variants]
	Let $\bar{x}$ be a sequence of variables. We say that two interpretations of the same signature $\Sigma$ are $\bar{x}$-variants if they coincide on all symbols and all variables not occurring in $\bar{x}$.
\end{definition*}

\begin{definition*}[Extension of interpretation]
	Let $I$ be an interpretation and $t$ a term of sort $\alpha$. Define an element $t^I \in I(\alpha)$ as follows.
	\begin{itemize}
		\item for constants $c: \alpha$ and variables $x: \alpha$ we have $c^I \iff I(c)$ and $x^I \iff I(x)$.
		\item $f(t_1,...,t_n)^I \iff f'(t_1^I,...,t_n^I)$.
		\item $p(t_1,...,t_n)^I = 1 \iff (t_1^I,...,t_n^I) \in p^I$.
		\item for connectives as before, e.g. $(A\rightarrow B)^I \iff (A^I = 0 \lor B^I = 1)$
		\item $(\forall x A)^I = 1$ iff for all $\bar{x}$-variants $I'$ of $I$ we have $(A)^{I'} = 1$.
		\item $(\exists x A)^I = 1$ iff for some $\bar{x}$-variants $I'$ of $I$ we have $(A)^{I'} = 1$.
	\end{itemize}
\end{definition*}

\begin{definition*}[Satisfiable, Valid]
	A formula $A$ with free variables $\bar{x}$ is said to be satisfiable in an interpretation $I$ if for some $\bar{x}$-variant $I'$ of $A$ we have $I' \models A$.
	
	$A$ is satisfiable iff it is satisfiable in some interpretation.
	
	A formula $A$ with free variables $\bar{x}$ is said to be valid in an interpretation $I$ if for every $\bar{x}$-variant $I'$ of $A$ we have $I' \models A$.
	
	$A$ is valid iff it is valid in every interpretation.
\end{definition*}

$A$ is valid iff $\lnot A$ is unsatisfiable.

\section{SMT, Theory of Equality, DPLL(T)}

\section{Theory of Arrays, Theory Combination, Nelson-Oppen, Z3}

\section{First-Order Theorem Proving, TPTP, Inference Systems}

\section{Selection functions, Saturation, Fairness and Redundancy}

\section{Redundancy, First-Order Reasoning with Equality}

\section{Ground Superposition, Term Orderings}

\section{Unification and Lifting}

\section{Non-Ground Superposition}

\end{document}
