\documentclass[]{article}
\usepackage[a4paper, margin=2.5cm]{geometry}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{amsthm}
\usepackage[many]{tcolorbox}
\usepackage{listings}

\newtheorem{lemma}{Lemma}
\newtheorem*{definition*}{Def}
\newtheorem{algorithm}{Algorithm}

\tcolorboxenvironment{lemma}{
	colback=yellow!5!white,
	boxrule=0pt,
	boxsep=1pt,
	left=2pt,right=2pt,top=2pt,bottom=2pt,
	oversize=2pt,
	sharp corners,
	before skip=\topsep,
	after skip=\topsep,
}

\tcolorboxenvironment{definition*}{
	colback=green!5!white,
	boxrule=0pt,
	boxsep=1pt,
	left=2pt,right=2pt,top=2pt,bottom=2pt,
	oversize=2pt,
	sharp corners,
	before skip=\topsep,
	after skip=\topsep,
}
\begin{document}
	
\title{Automated Deduction Compendium SS2023}
\author{Ida HÃ¶nigmann}

\maketitle

\section{Introduction, SAT Solving}

\subsubsection{Proposition, Formulas}
\begin{definition*}[Proposition]
	Proposition is a statement that can be either true or false.
\end{definition*}

\begin{definition*}[Propositional formula, Atom, Connective]
	Atoms are boolean variables (e.g. p,q).
	
	\begin{enumerate}
		\item Atoms are formulas.
		\item $\top$, $\bot$ are formulas.
		\item If $A$ is a formula, then $\lnot A$ is a formula.
		\item If $A_1, ..., A_n$ are formulas, then $(A_1 \land ... \land A_n)$ and $(A_1 \lor ... \lor A_n)$ are formulas.
		\item If $A$ and $B$ are formulas, then $A \rightarrow B$ and $A \leftrightarrow B$ are formulas.
	\end{enumerate}

	The symbols $\top, \bot, \land, \lor, \lnot, \rightarrow, \leftrightarrow$ are called logical connectives.
\end{definition*}

\subsubsection{Precedence}
\begin{center}
	\begin{tabular}{|c c c|}
		\hline
		Connective & Name & Precedence \\
		\hline
		$\top$            & verum       &   \\  
		$\bot$            & falsum      &   \\
		$\lnot$           & negation    & 5 \\  
		$\land$           & conjunction & 4 \\
		$\lor$            & disjunction & 3 \\  
		$\rightarrow$     & implication & 2 \\
		$\leftrightarrow$ & equivalence & 1 \\  
		\hline
	\end{tabular}
\end{center}

\subsubsection{Boolean Values, Interpretation}
\begin{definition*}[Boolean values, Interpretation]
	There are two boolean vales: true ($1$) and false ($0$).
	
	An interpretation for a set $P$ of boolean variables is a mapping $I : P \rightarrow \{0,1\}$.
\end{definition*}

\subsubsection{Interpreting formulas}
\begin{enumerate}
	\item $I(\top) = 1$ and $I(\bot) = 0$
	\item $I(A_1 \land ... \land A_n) = 1$ iff $I(A_i) = 1$ for all $i$
	\item $I(A_1 \lor ... \lor A_n) = 1$ iff $I(A_i) = 1$ for some $i$
	\item $I(\lnot A) = 1$ iff $I(A) = 0$
	\item $I(A_1 \rightarrow A_2) = 1$ iff $I(A_1) = 0$ or $I(A_2) = 1$
	\item $I(A_1 \leftrightarrow A_2) = 1$ iff $I(A_1) = I(A_2)$
\end{enumerate}

\subsubsection{Safisfiable, Valid, Model}
\begin{definition*}[Satisfiable, Model, Valid]
	If $I(A) = 1$ then $I$ satisfies $A$ and $I$ is a model of $A$, denoted by $I \models A$.
	
	$A$ is satisfiable if some interpretation is a model of $A$.
	
	$A$ is valid if every interpretation is a model of $A$.
	
	$A$ and $B$ are equivalent, denoted by $A \equiv B$, if they have the same models.
\end{definition*}

\subsubsection{Connection valid, satisfiable}
\begin{enumerate}
	\item $A$ is valid iff $\lnot A$ is unsatisfiable.
	\item $A$ is satisfiable iff $\lnot A$ is not valid.
\end{enumerate}

\subsubsection{Equivalent replacement}
\begin{definition*}[Equivalent replacement]
	$A[B]$ is a formula $A$ with a fixed occurrence of subformula $B$. $A[B']$ is the formula $A$ where every occurrence of $B$ is replaced by $B'$.
\end{definition*}

\begin{lemma}[Equivalent Replacement]
	Let $I$ be an interpretation and $I \models A_1 \leftrightarrow A_2$. Then $I \models B[A_1] \leftrightarrow B[A_2]$.
	
	Let $A_1 \equiv A_2$. Then $B[A_1] \equiv B[A_2]$.
\end{lemma}


\subsubsection{Evaluating a formula}
\begin{algorithm}
\begin{verbatim}
procedure evaluate(G,I)
input: formula G, interpretation I
output: the boolean value I(G)
begin
  forall atoms p occurring in G
    if I models p
      then replace all occurrences of p in G by 1;
      else replace all occurrences of p in G by 0;
  rewrite G into a normal form using the rewrite rules
  if G = 1 then return 1 else return 0
end
\end{verbatim}
\end{algorithm}

\section{Splitting, Polarities}

\subsubsection{Soundness of Splitting}

$A_p^\bot$ and $A_p^\top$ are obtained by replacing in $A$ all occurrences of $p$ by $\bot$ and $\top$ respectively.

\begin{lemma}
	Let $p$ be an atom, $A$ be a formula, and $I$ be an interpretation.
	
	\begin{enumerate}
		\item If $I \not\models p$, then $A$ is equivalent to $A_p^\bot$ in $I$.
		\item If $I \models p$, then $A$ is equivalent to $A_p^\top$ in $I$.
	\end{enumerate}
\end{lemma}

\begin{lemma}
	Let $A$ be a formula and $p$ an atom.
	
	Then $A$ is satisfiable iff at least one of the formulas $A_p^\top$ and $A_p^\bot$ is satisfiable.
\end{lemma}

\subsubsection{Splitting}

\begin{algorithm}
	\begin{verbatim}
		procedure split(G)
		parameters: function select
		input: formula G
		output: ''satisfiable'' or ''unsatisfiable''
		begin
		  G := simplify(G)		# rewrite rules
		  if G = 1 then return ''satisfiable''
		  if G = 0 then return ''unsatisfiable''
		  (p,b) := select(G)
		  case b of
		  1 =>
		    if split(replace(G,p,1)) = ''satisfiable''
		      then return ''satisfiable''
		      else return split(replace(G,p,0))
		  0 =>
		    if split(replace(G,p,0)) = ''satisfiable''
		      then return ''satisfiable''
		      else return split(replace(G,p,1))
		end
	\end{verbatim}
\end{algorithm}

\subsubsection{Polarities}
\begin{enumerate}
	\item $A|_\epsilon = A$ and $pol(A,\epsilon) = 1$
	\item If $A|\pi = B_1 \land ... \land B_n$ or $A|\pi = B_1 \lor ... \lor B_n$ then $A|_{\pi.i} = B_i$ and $pol(A,\pi.i) = pol(A,\pi)$.
	\item If $A|_pi = \lnot B$ then $A|_{\pi.1} = B$ and $pol(A,\pi.1) = -pol(A,\pi)$.
	\item If $A|_\pi = B_1 \rightarrow B_2$ then $A|_{\pi.1} = B_1$, $A|_{\pi.2} = B_2$ and $pol(A,\pi.1) = -pol(A,\pi)$, $pol(A,\pi.2) = pol(A,\pi)$.
	\item If $A|_\pi = B_1 \leftrightarrow B_2$ then $A|_{\pi.1} = B_1$, $A|_{\pi.2} = B_2$ and $pol(A,\pi.1) = 0 = pol(A,\pi.2)$.
\end{enumerate}

\subsubsection{Monotonic replacement}

Denote with $A[B]_\pi$ formula $A$ with the subformula at the position $\pi$ replaced by $B$.

\begin{lemma}[Monotonic Replacement]
	Let $A,B,B'$ be formulas, $I$ be an interpretation, and $I \models B \rightarrow B'$. If $pol(A,\pi) = 1$, then $I \models A[B]_\pi \rightarrow A[B']_\pi$. Likewise, if $pol(A,\pi) = -1$ then $I \models A[B']_\pi \rightarrow A[B]_\pi$.
\end{lemma}

\subsubsection{Pure Atom}

\begin{definition*}
	Atom $p$ is pure in a formula $A$, if either all occurrences of $p$ in $A$ are positive or all occurrences of $p$ in $A$ are negative.
\end{definition*}

\begin{lemma}[Pure Atom]
	Let $p$ have only positive occurrences in $A$ and $I \models A$. Define $I' = I + (p\mapsto 1)$. Then $I' \models A$. Likewise, let $p$ have only negative occurrences in $A$ and $I \models A$. Define $I' = I + (p\mapsto 0)$. Then $I' \models A$.
\end{lemma}

\begin{lemma}[Pure Atom]
	Let an atom $p$ have only positive (respectively, only negative) occurrences in $A$. Then $A$ is satisfiable iff $A_p^\top$ (respectively, $A_p^\bot$) is satisfiable.
\end{lemma}

\subsubsection{Splitting with pure atom optimization}

\begin{algorithm}
	\begin{verbatim}
		procedure split(G)
		parameters: function select
		input: formula G
		output: ''satisfiable'' or ''unsatisfiable''
		begin
		  G := simplify_with_pure_atoms(G)
		  if G = 1 then return ''satisfiable''
		  if G = 0 then return ''unsatisfiable''
		  (p,b) := select(G)
		  case b of
		  1 =>
		    if split(replace(G,p,1)) = ''satisfiable''
		      then return ''satisfiable''
		      else return split(replace(G,p,0))
		  0 =>
		    if split(replace(G,p,0)) = ''satisfiable''
		      then return ''satisfiable''
		      else return split(replace(G,p,1))
		end
	\end{verbatim}
\end{algorithm}

\section{CNF, DPLL, MiniSat}

\subsubsection{Clause}

\begin{definition*}[Literal, Clause, Empty clause, Unit clause, Horn clause]
	A literal is either an atom $p$ or its negation $\lnot p$.
	
	A clause is a disjunction of literals $L_1 \lor ... \lor L_n$.
	
	The empty clause $\square$ is false in every interpretation.
	
	If $n=1$ then the clause is called unit clause.
	
	A horn clause is a clause with at most one positive literal.
\end{definition*}

\subsubsection{CNF}

\begin{definition*}[CNF]
	A formula $A$ is in conjenctive normal form if it is $\top$, $\bot$ or a conjunction of disjunctions of literals $\bigwedge_i \bigvee_j L_{i,j}$.
\end{definition*}

\subsubsection{Naming}

If A is a non-trivial subformula $A$. Introduce a new name $n$ for it. Add formula $n \leftrightarrow A$ and replace subformula by its name in the original formula.

\begin{lemma}[Naming]
	Let $S$ be a set of formulas and $A$ a formula. Let $n$ be a boolean variable not occurring in $S$, nor in $A$.
	
	Then $S$ is satisfiable iff the set of formulas $S \cup \{n \leftrightarrow A\}$ is satisfiable.
\end{lemma}

\subsubsection{Optimized CNF Transformation}

Introduce a new name $n$ every subformula $B$ and replace it with the name. If the subformula occurs only positively then add $n \rightarrow B$. If it occurs only negatively then add $B \rightarrow n$ and if it does not occur only positively or negatively than add $n \leftrightarrow B$.

\begin{lemma}
	A set of formulas is satisfiable iff the optimized CNF transformation of these formulas is satisfiable.
\end{lemma}

\subsubsection{Unit propagation}

Let $S$ be a set of clauses. If $S$ contains a unit clause $L$ then remove from $S$ every clause of the form $L \lor C$ and replace in $S$ every clause of the form $\bar{L} \lor C$ by the clause $C$.

\subsubsection{DPLL = splitting + unit propagation}

\begin{algorithm}
	\begin{verbatim}
		procedure DPLL(S)
		input: set of clauses S
		output: satisfiable or unsatisfiable
		parameters: function select_literal
		begin
		  S := propagate(S) # unit propagation
		  if S is empty then return satisfiable
		  if S contains 0 then return unsatisfiable
		  L := select_literals(S) # splitting
		  if DPLL(S union {L}) = satisfiable
		    then return satisfiable
		    else return DPLL(S union {not L})
		end
	\end{verbatim}
\end{algorithm}

Tautologies (e.g. $p \lor \lnot p \lor C$) can be removed.

\subsubsection{Pure literals}

\begin{definition*}[Pure literal]
	A literal $L$ in $S$ is called pure if $S$ contains no clauses of the form $\bar{L} \lor C$.
\end{definition*}

If $L$ is a pure literal in $S$ then all clauses containing this literal can be removed.

\section{Random SAT, Horn clauses}

\section{First-Order Logic, Theories}

\section{SMT, Theory of Equality, DPLL(T)}

\section{Theory of Arrays, Theory Combination, Nelson-Oppen, Z3}

\section{First-Order Theorem Proving, TPTP, Inference Systems}

\section{Selection functions, Saturation, Fairness and Redundancy}

\section{Redundancy, First-Order Reasoning with Equality}

\section{Ground Superposition, Term Orderings}

\section{Unification and Lifting}

\section{Non-Ground Superposition}

\end{document}
